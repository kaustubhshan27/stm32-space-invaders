/*
 * space_invaders.c
 *
 *  Created on: Aug 3, 2023
 *      Author: kaustubh
 */

#include <stdint.h>
#include <string.h>
#include "stm32f4xx_hal.h"
#include "space_invaders.h"
#include "nokia5110.h"
#include "gpio.h"
#include "random.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

// image of the player's ship
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=18 x height=8
static const uint8_t player_ship[] = { 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4,
		0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF };

// a laser burst in flight
// includes one blacked out row on the top and bottom of the image to prevent smearing when moved 1 pixel up or down
// width=2 x height=9
static const uint8_t laser[] = { 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
		0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80,
		0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 0x00,
		0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (undamaged)
// width=18 x height=5
static const uint8_t bunker_light[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (moderate generic damage)
// width=18 x height=5
static const uint8_t bunker_medium[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0xA0, 0xA0, 0xAA, 0xAA, 0xA0,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0x00, 0x0A, 0x0A, 0x0A,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (heavy generic damage)
// width=18 x height=5
static const uint8_t bunker_heavy[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0xA0, 0xAA, 0xA0, 0xA0, 0xA0,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0x00, 0xA0, 0xA0, 0xA0, 0x00,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x0A, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// enemy ship that starts at the top of the screen (arms/mouth closed)
// width=16 x height=10
static const uint8_t enemy_ship[] = { 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0xF0,
		0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF };

// small explosion best used for the demise of an enemy
// width=16 x height=10
const uint8_t small_explosion[] = { 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF0, 0x0F, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0xF0,
		0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F,
		0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
		0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
		0xF0, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF };

// large explosion that can be used upon the demise of the player's ship (first frame)
// width=18 x height=8
const uint8_t big_explosion[] = { 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x90, 0xB0, 0x0A, 0x00, 0x0B, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0B, 0xA0, 0x00, 0xE0, 0x00, 0x00, 0x90, 0x90, 0x9A,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xAE, 0x00,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0xE0, 0x0A, 0x0A, 0x00, 0x00, 0xB0,
		0x00, 0x00, 0x00, 0xA0, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0A,
		0x00, 0x00, 0x00, 0xFF };

// collection of all the objects involved in the game
game_objects_t game_entities;

// collection of all the current stats of the game
game_stats_t game_info;

// semaphore to indicate user missile creation
SemaphoreHandle_t xSemaphrHandle_user_missile_gen = NULL;

// global mutex for all tasks
SemaphoreHandle_t xSemaphrHandle_global_mutex = NULL;

// indicates a user missile to be fired
volatile uint8_t user_missile_flag = 0;

/**
 * @brief Initialize the attributes of user and enemy lasers.
 *
 * This static function initializes the attributes of user and enemy lasers.
 * It sets the initial hit statuses, positions, images, and life status for each laser.
 */
static void lasers_init(void) {
	// initializing all user lasers
	for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
		/* if the user laser is going to hit an enemy sprite -
		 * enemy0: hit_status = 0,
		 * enemy1: hit_status = 1,
		 * enemy2: hit_status = 2,
		 * else hit_status = -1 */
		game_entities.user_laser[i].hit_status = -1;
		game_entities.user_laser[i].laser_sprite.x = 0;
		game_entities.user_laser[i].laser_sprite.y = 0;
		game_entities.user_laser[i].laser_sprite.image = laser;
		game_entities.user_laser[i].laser_sprite.life = 0;
	}

	// initializing all enemy lasers
	for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
		/* if the enemy laser is going to hit the bunker -
		 * hit_status = 1,
		 * else hit_status=0 */
		game_entities.enemy_laser[i].hit_status = 0;
		game_entities.enemy_laser[i].laser_sprite.x = 0;
		game_entities.enemy_laser[i].laser_sprite.y = 0;
		game_entities.enemy_laser[i].laser_sprite.image = laser;
		game_entities.enemy_laser[i].laser_sprite.life = 0;
	}
}

/**
 * @brief Initialize the positions and attributes of game entities.
 *
 * This static function initializes the positions and attributes of enemies, the player, and bunkers.
 * It sets the initial positions and images for each entity, as well as their initial life status.
 */
static void sprites_pos_init(void) {
	// enemy initialization
	for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
		game_entities.enemy[i].x = 32 * i;
		game_entities.enemy[i].y = ENEMYH - 1;
		game_entities.enemy[i].image = enemy_ship;
		game_entities.enemy[i].life = 1;
	}

	// player initialization
	game_entities.user.x = 32;
	game_entities.user.y = 47;
	game_entities.user.image = player_ship;
	game_entities.user.life = 1;

	// bunker initialization
	game_entities.bunker.x = 32;
	game_entities.bunker.y = 47 - PLAYERH;
	game_entities.bunker.image = bunker_light;
	game_entities.bunker.life = 3;
}

/**
 * @brief Draw the game entities and their positions on the Nokia 5110 screen.
 *
 * This static function clears the buffer, then fills it with the images of enemies, the player,
 * bunkers, user lasers, and enemy lasers based on their respective positions. It finally displays
 * the buffer on the Nokia 5110 screen to provide a visual representation of the game state.
 */
static void draw(void) {
	// clearing the buffer before drawing
	Nokia5110_ClearBuffer();

	// filling the buffer with enemies
	for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
		Nokia5110_PrintBMP(game_entities.enemy[i].x,
		game_entities.enemy[i].y, game_entities.enemy[i].image, 0);
	}

	// filling the buffer with the user
	Nokia5110_PrintBMP(game_entities.user.x, game_entities.user.y,
	game_entities.user.image, 0);

	// filling the buffer with the bunker
	if (game_entities.bunker.life > 0) {
		Nokia5110_PrintBMP(game_entities.bunker.x, game_entities.bunker.y,
				game_entities.bunker.image, 0);
	}

	// filling the buffer with the user lasers
	for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
		if (game_entities.user_laser[i].laser_sprite.life > 0) {
			Nokia5110_PrintBMP(game_entities.user_laser[i].laser_sprite.x,
					game_entities.user_laser[i].laser_sprite.y,
					game_entities.user_laser[i].laser_sprite.image, 0);
		}
	}

	// filling the buffer with the enemy lasers
	for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
		if (game_entities.enemy_laser[i].laser_sprite.life > 0) {
			Nokia5110_PrintBMP(game_entities.enemy_laser[i].laser_sprite.x,
					game_entities.enemy_laser[i].laser_sprite.y,
					game_entities.enemy_laser[i].laser_sprite.image, 0);
		}
	}

	// display the buffer on Nokia 5110
	Nokia5110_DisplayBuffer();
}

/**
 * @brief Display the game start message on the Nokia 5110 screen.
 *
 * This static function clears the screen and displays the game title along with a message to begin the game.
 * It uses the Nokia 5110 screen to provide visual output.
 */
static void game_start_msg(void) {
	Nokia5110_Clear();
	Nokia5110_SetCursor(1, 1);
	Nokia5110_OutString("SPACE");
	Nokia5110_SetCursor(1, 2);
	Nokia5110_OutString("INVADERS");
	Nokia5110_SetCursor(1, 4);
	Nokia5110_OutString("Begin Game!");
}

/**
 * @brief Display the end game message on the Nokia 5110 screen.
 *
 * This function clears the screen and displays either a victory message with the score
 * or a defeat message depending on the game outcome. It utilizes the Nokia 5110 screen
 * for visual output.
 */
void game_end_msg(void) {
	Nokia5110_Clear();

	if (game_info.kill_count == NUMBER_OF_ENEMIES) {
		/* player won message */
		Nokia5110_SetCursor(1, 1);
		Nokia5110_OutString("YOU WON!");
		Nokia5110_SetCursor(2, 4);
		Nokia5110_OutUDec(game_info.kill_count * POINTS_PER_KILL);
	} else {
		/* player lost message */
		Nokia5110_SetCursor(1, 1);
		Nokia5110_OutString("GAME OVER");
		Nokia5110_SetCursor(1, 2);
		Nokia5110_OutString("Try Again,");
		Nokia5110_SetCursor(1, 3);
		Nokia5110_OutString("Earthling!");
		Nokia5110_SetCursor(2, 4);
		Nokia5110_OutUDec(game_info.kill_count * POINTS_PER_KILL);
	}
}

/**
 * @brief Initialize the game entities and start the game.
 *
 * This function initializes the game entities, such as player, enemies, bunkers, and laser arrays.
 * It clears the game statistics structure and displays the game start message on the screen,
 * followed by the initial playing position. It then delays to let the messages persist on the display.
 */
void game_init(void) {
	/* initialize the game entities */
	sprites_pos_init();
	lasers_init();
	memset((void*) &game_info, 0, sizeof(game_stats_t));

	/* display the game start message */
	game_start_msg();

	/* let the start message persist on the display - 2 secs */
	vTaskDelay(PERSIST_PERIOD / portTICK_PERIOD_MS);

	/* display the initial playing position */
	draw();
}

/**
 * @brief Task function responsible for generating user lasers in the game.
 *
 * This task function generates user lasers whenever the semaphore indicates a missile should be fired.
 * It calculates the appropriate position and direction for the laser and checks for collisions with enemies.
 */
void user_laser_generation(void) {
	while (1) {
		if (xSemaphoreTake(xSemaphrHandle_user_missile_gen,
				portMAX_DELAY) == pdPASS) {

			if (xSemaphoreTake(xSemaphrHandle_global_mutex,
					portMAX_DELAY) == pdPASS) {
				/* generate the laser */
				uint8_t missile_index;
				for (missile_index = 0; missile_index < USER_MISSILE_MAX;
						missile_index++) {
					if (game_entities.user_laser[missile_index].laser_sprite.life
							== 0) {
						game_entities.user_laser[missile_index].laser_sprite.x =
								game_entities.user.x + (PLAYERW / 2) - 1;
						game_entities.user_laser[missile_index].laser_sprite.y =
						SCREENH - 1 - PLAYERH;
						game_entities.user_laser[missile_index].laser_sprite.image =
								laser;
						game_entities.user_laser[missile_index].laser_sprite.life =
								1;
						game_info.user_missile_count++;

						break;
					}
				}

				game_entities.user_laser[missile_index].hit_status = -1;

				/* check which enemy the generated laser is destined to hit */
				for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
					if ((game_entities.user_laser[missile_index].laser_sprite.x
							>= game_entities.enemy[i].x)
							&& (game_entities.user_laser[missile_index].laser_sprite.x
									<= game_entities.enemy[i].x + ENEMYW)
							&& game_entities.enemy[i].life) {
						game_entities.user_laser[missile_index].hit_status = i;
						break;
					}
				}
			}
			xSemaphoreGive(xSemaphrHandle_global_mutex);
		}
	}
}

/**
 * @brief Task function responsible for generating enemy lasers in the game.
 *
 * This task function generates enemy lasers at a specific interval. It chooses an enemy
 * based on a random selection and creates enemy lasers to be fired towards the player's
 * position.
 */
void enemy_laser_generation(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	while (1) {
		/* generate an enemy laser with a period of 2 secs */
		vTaskDelayUntil(&xLastWakeTime,
		ENEMY_LASER_GENERATION_PERIOD / portTICK_PERIOD_MS);

		if (xSemaphoreTake(xSemaphrHandle_global_mutex, portMAX_DELAY) == pdPASS) {
			if (game_info.enemy_missile_count < ENEMY_MISSILE_MAX) {
				/* using bits 31-24 of the random number will produce a number sequence with a cycle length of 2^24 */
				uint8_t enemy_choice = (Random32() >> 24) % NUMBER_OF_ENEMIES;
				while (game_entities.enemy[enemy_choice].life == 0) {
					enemy_choice = (enemy_choice + 1) % NUMBER_OF_ENEMIES;
				}

				game_info.enemy_missile_count++;

				for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
					if (game_entities.enemy_laser[i].laser_sprite.life == 0) {
						game_entities.enemy_laser[i].laser_sprite.x =
								game_entities.enemy[enemy_choice].x + ENEMYW / 2
										- 1;
						game_entities.enemy_laser[i].laser_sprite.y =
								game_entities.enemy[enemy_choice].y + ENEMYH;
						game_entities.enemy_laser[i].laser_sprite.image = laser;
						game_entities.enemy_laser[i].laser_sprite.life = 1;

						if (((game_entities.enemy_laser[i].laser_sprite.x
								>= game_entities.bunker.x)
								&& (game_entities.enemy_laser[i].laser_sprite.x
										<= game_entities.bunker.x + BUNKERW))
								&& game_entities.bunker.life != 0) {
							game_entities.enemy_laser[i].hit_status = 1;
						} else {
							game_entities.enemy_laser[i].hit_status = 0;
						}
						break;
					}
				}
			}
		}
		xSemaphoreGive(xSemaphrHandle_global_mutex);
	}
}

/**
 * @brief Task function responsible for managing the movement and collision of lasers in the game.
 *
 * This task function handles the movement of both user and enemy lasers, checks for collisions,
 * and updates the game state accordingly.
 */
void laser_movement(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	while (1) {
		/* generate an enemy laser with a period of 0.5 secs */
		vTaskDelayUntil(&xLastWakeTime,
		LASER_MOVEMENT_PERIOD / portTICK_PERIOD_MS);

		if (xSemaphoreTake(xSemaphrHandle_global_mutex, portMAX_DELAY) == pdPASS) {
			/* user laser movement */
			if (game_info.user_missile_count > 0) {
				for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
					if (game_entities.user_laser[i].laser_sprite.life == 1) {
						game_entities.user_laser[i].laser_sprite.y -=
						USER_LASER_DISPLACEMENT;

						if ((game_entities.user_laser[i].hit_status >= 0)
								&& ((game_entities.user_laser[i].laser_sprite.y
										- LASERH)
										<= game_entities.enemy[game_entities.user_laser[i].hit_status].y)) {
							game_entities.enemy[game_entities.user_laser[i].hit_status].image =
									small_explosion;
							game_entities.enemy[game_entities.user_laser[i].hit_status].life = 0;
							game_entities.user_laser[i].hit_status = -1;
							game_entities.user_laser[i].laser_sprite.life = 0;
							game_info.user_missile_count--;
							game_info.kill_count++;
							if (game_info.kill_count == NUMBER_OF_ENEMIES) {
								game_info.game_over_flag = 1;
							}
						} else if (game_entities.user_laser[i].laser_sprite.y
								<= 0) {
							game_entities.user_laser[i].hit_status = -1;
							game_entities.user_laser[i].laser_sprite.life = 0;
							game_info.user_missile_count--;
						}
					}
				}
			}

			/* enemy laser movement */
			if (game_info.enemy_missile_count > 0) {
				for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
					if (game_entities.enemy_laser[i].laser_sprite.life == 1) {
						game_entities.enemy_laser[i].laser_sprite.y +=
						ENEMY_LASER_DISPLACEMENT;

						if (game_entities.enemy_laser[i].hit_status == 1) /* enemy laser to hit the bunker */
						{
							if ((game_entities.enemy_laser[i].laser_sprite.y
									>= game_entities.bunker.y - BUNKERH)
									&& (game_entities.bunker.life > 0)) {
								game_entities.enemy_laser[i].laser_sprite.life =
										0;
								game_entities.bunker.life--;
								switch (game_entities.bunker.life) {
								case 1:
									game_entities.bunker.image = bunker_heavy;
									break;
								case 2:
									game_entities.bunker.image = bunker_medium;
									break;
								default:
									break;
								}
							}
						} else if ((game_entities.enemy_laser[i].laser_sprite.x
								>= game_entities.user.x)
								&& (game_entities.enemy_laser[i].laser_sprite.x
										<= game_entities.user.x + PLAYERW)) /* enemy laser to hit the user */
								{
							if (game_entities.enemy_laser[i].laser_sprite.y
									>= game_entities.user.y - PLAYERH) {
								game_entities.user.image = big_explosion;
								game_entities.user.life = 0;
								game_entities.enemy_laser[i].laser_sprite.life =
										0;
								game_info.enemy_missile_count--;
								game_info.game_over_flag = 1;
							}
						} else if (game_entities.enemy_laser[i].laser_sprite.y
								- LASERH >= SCREENH - 1) {
							game_entities.enemy_laser[i].laser_sprite.life = 0;
							game_info.enemy_missile_count--;
						}
					}
				}
			}
		}
		xSemaphoreGive(xSemaphrHandle_global_mutex);
	}
}

/**
 * @brief Task function responsible for periodically drawing an image to the display.
 *
 * This task function is used to draw images on the display screen at a specific refresh rate.
 * The drawing process is performed inside a critical section.
 */
void draw_image(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	while (1) {
		/* generate an enemy laser with a freq. of 60 Hz=0.0166 secs */
		vTaskDelayUntil(&xLastWakeTime,
		SCREEN_REFRESH_PERIOD / portTICK_PERIOD_MS);

		if (xSemaphoreTake(xSemaphrHandle_global_mutex, portMAX_DELAY) == pdPASS) {
			draw();
		}
		xSemaphoreGive(xSemaphrHandle_global_mutex);
	}
}

/**
 * @brief Main function for the Space Invaders game application.
 *
 * This function initializes game metrics, creates tasks for various game
 * functionalities, and manages the game loop.
 */
void space_invaders_app(void) {
	TaskHandle_t xTaskHandle_userLaserGeneration = NULL;
	TaskHandle_t xTaskHandle_enemyLaserGeneration = NULL;
	TaskHandle_t xTaskHandle_laserMovement = NULL;
	TaskHandle_t xTaskHandle_drawImage = NULL;

	/* initialize all game metrics */
	game_init();

	/* global mutex to manage global struct access */
	xSemaphrHandle_global_mutex = xSemaphoreCreateMutex();
	assert_param(xSemaphrHandle_global_mutex != NULL);

	/* to synchronize with the user missile generation task */
	xSemaphrHandle_user_missile_gen = xSemaphoreCreateCounting(USER_MISSILE_MAX,
			0);
	assert_param(xSemaphrHandle_user_missile_gen != NULL);

	/* task to draw an image to Nokia 5110 */
	assert_param(
			xTaskCreate((pdTASK_CODE) draw_image, "Draw Image", TASK_STACK_SIZE, NULL, 2, &xTaskHandle_drawImage) == pdPASS);

	/* create the user and enemy laser movement task */
	assert_param(
			xTaskCreate((pdTASK_CODE) laser_movement, "User & Enemy Laser Movement", TASK_STACK_SIZE, NULL, 3, &xTaskHandle_laserMovement) == pdPASS);

	/* create the enemy laser generation task */
	assert_param(
			xTaskCreate((pdTASK_CODE) enemy_laser_generation, "Enemy Laser Generation", TASK_STACK_SIZE, NULL, 4, &xTaskHandle_enemyLaserGeneration) == pdPASS);

	/* create the user laser generation task */
	assert_param(
			xTaskCreate((pdTASK_CODE) user_laser_generation, "User Laser Generation", TASK_STACK_SIZE, NULL, 5, &xTaskHandle_userLaserGeneration) == pdPASS);

	while (1) {
		if(user_missile_flag == 1)
		{
			user_missile_flag = 0;
			xSemaphoreGive(xSemaphrHandle_user_missile_gen);
		}
		/* if the game has ended, display the final image */
		if (game_info.game_over_flag) {
			/* delete all tasks */
			vTaskDelete(xTaskHandle_laserMovement);
			vTaskDelete(xTaskHandle_enemyLaserGeneration);
			vTaskDelete(xTaskHandle_userLaserGeneration);
			vTaskDelete(xTaskHandle_drawImage);

			draw();
			/* let the  last image of the game persist on the display - 1 secs */
			vTaskDelay(PERSIST_PERIOD / portTICK_PERIOD_MS);
			game_end_msg();

			vTaskDelete(NULL);
		}
	}
}
